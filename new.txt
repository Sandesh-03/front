
// User model used across the Angular app
export interface User {
  id?: string;                // optional (comes from backend DB)
  email: string;              // required
  password: string;           // required
  role: 'patient' | 'doctor'; // required
  fullName: string;           // required
  phone?: string;

  // Patient-specific fields
  gender?: string;
  dateOfBirth?: Date | string;
  address?: string;

  // Doctor-specific fields
  specialization?: string;
  qualification?: string;
  experience?: number;
  consultationFee?: number;
  department?: string;
}

// For login requests (only email + password needed)
export interface LoginRequest {
  email: string;
  password: string;
}

// For register requests (everything except `id`)
export interface RegisterRequest {
  email: string;
  password: string;
  role: 'patient' | 'doctor';
  fullName: string;
  phone?: string;

  // Patient-specific fields
  gender?: string;
  dateOfBirth?: Date | string;
  address?: string;

  // Doctor-specific fields
  specialization?: string;
  qualification?: string;
  experience?: number;
  consultationFee?: number;
  department?: string;
}



src/services/auth.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, of } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { User } from '../models/user.model';

interface AuthResponse {
  token: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser$: Observable<User | null> = this.currentUserSubject.asObservable();

  private authBaseUrl = 'http://localhost:4002/api/Auth';   // AuthController
  // NOTE: Registering doctor/patient profiles is NOT exposed by your current DoctorService.
  // PatientService POST /api/Patient is Admin-only. So registration here only calls Auth.

  constructor(private http: HttpClient) {}

  // --- Registration (Auth only) ---
  register(profile: { email: string; password: string; role: 'Admin' | 'Doctor' | 'Patient' }) {
    const body = {
      email: profile.email,
      password: profile.password,
      role: profile.role
    };
    return this.http.post(`${this.authBaseUrl}/register`, body);
  }

  // --- Login ---
  login(email: string, password: string) {
    const body = { email, password };
    return this.http.post<AuthResponse>(`${this.authBaseUrl}/login`, body);
  }

  // --- Logout / Session helpers ---
  logout(): void {
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
    this.currentUserSubject.next(null);
  }

  isLoggedIn(): boolean {
    return !!localStorage.getItem('authToken');
  }

  getCurrentUser(): User | null {
    // Prefer live BehaviorSubject; fallback to localStorage decode
    const live = this.currentUserSubject.value;
    if (live) return live;

    const token = localStorage.getItem('authToken');
    if (!token) return null;

    const user = this.decodeUserFromToken(token);
    if (user) this.currentUserSubject.next(user);
    return user;
  }

  hasRole(role: string): boolean {
    const user = this.getCurrentUser();
    if (!user) return false;
    return user.role.toLowerCase() === role.toLowerCase();
  }

  // Build a User object from the JWT (AuthService adds NameIdentifier + Role)
  private decodeUserFromToken(token: string): User | null {
    try {
      const [, payloadB64] = token.split('.');
      const json = JSON.parse(atob(payloadB64));

      // .NET ClaimTypes are usually full URIs; also check short keys just in case
      const ROLE_KEYS = [
        'role',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/role',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/role'
      ];
      const ID_KEYS = [
        'nameid',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier'
      ];
      const EMAIL_KEYS = [
        'email',
        'unique_name',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress'
      ];

      const role =
        ROLE_KEYS.map(k => json[k]).find(v => !!v) ??
        'Patient'; // default if missing

      const idStr =
        ID_KEYS.map(k => json[k]).find(v => !!v) ?? '0';
      const id = Number(idStr) || 0;

      const email =
        EMAIL_KEYS.map(k => json[k]).find(v => !!v) ?? '';

      const user: User = {
        id,
        email,
        role: role as User['role']
      };

      return user;
    } catch {
      return null;
    }
  }

  // Expose a convenience for components after login to set the user
  setCurrentUserFromToken(token: string): void {
    const user = this.decodeUserFromToken(token);
    if (user) {
      localStorage.setItem('currentUser', JSON.stringify(user));
      this.currentUserSubject.next(user);
    }
  }
}

src/services/doctor.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface Doctor {
  id: number;
  name: string;
  specialty: string;
  availabilities: Array<{
    id: number;
    day: number;        // DayOfWeek (0=Sunday .. 6=Saturday)
    timeSlot: string;   // e.g. "09:00-10:00"
  }>;
}

@Injectable({
  providedIn: 'root'
})
export class DoctorService {
  private readonly baseUrl = 'http://localhost:4004/api/Doctors';

  constructor(private http: HttpClient) {}

  private authHeaders(): HttpHeaders {
    const token = localStorage.getItem('authToken') ?? '';
    return new HttpHeaders({
      Authorization: token ? `Bearer ${token}` : ''
    });
  }

  // Admin-only per backend [Authorize(Roles="Admin")]
  getAllDoctors(): Observable<Doctor[]> {
    return this.http.get<Doctor[]>(`${this.baseUrl}`, { headers: this.authHeaders() });
  }

  // Admin-only
  getDoctor(id: number): Observable<Doctor> {
    return this.http.get<Doctor>(`${this.baseUrl}/${id}`, { headers: this.authHeaders() });
  }

  // Admin-only
  deleteDoctor(id: number): Observable<void> {
    return this.http.delete<void>(`${this.baseUrl}/${id}`, { headers: this.authHeaders() });
  }
}

src/services/patient.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface MedicalHistory {
  id?: number;
  condition: string;
  notes: string;
}

export interface Patient {
  id?: number;
  fullName: string;
  gender: string;
  dob: string; // ISO date string (maps to backend DateTime DOB)
  medicalHistories?: MedicalHistory[];
}

@Injectable({
  providedIn: 'root'
})
export class PatientService {
  private readonly baseUrl = 'http://localhost:4005/api/Patient';

  constructor(private http: HttpClient) {}

  private authHeaders(): HttpHeaders {
    const token = localStorage.getItem('authToken') ?? '';
    return new HttpHeaders({
      Authorization: token ? `Bearer ${token}` : ''
    });
  }

  // Doctor,Admin
  getAll(): Observable<Patient[]> {
    return this.http.get<Patient[]>(`${this.baseUrl}`, { headers: this.authHeaders() });
  }

  // Doctor,Admin
  get(id: number): Observable<Patient> {
    return this.http.get<Patient>(`${this.baseUrl}/${id}`, { headers: this.authHeaders() });
  }

  // Admin-only (per backend)
  add(patient: Patient): Observable<Patient> {
    // Backend expects { FullName, Gender, DOB } â€“ keys are PascalCase in C#; JSON serializer is case-insensitive, so this is OK.
    const body = {
      fullName: patient.fullName,
      gender: patient.gender,
      dob: patient.dob
    };
    return this.http.post<Patient>(`${this.baseUrl}`, body, { headers: this.authHeaders() });
  }

  // Admin-only
  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.baseUrl}/${id}`, { headers: this.authHeaders() });
  }
}

src/guards/auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router, ActivatedRouteSnapshot } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot): boolean {
    if (!this.auth.isLoggedIn()) {
      this.router.navigate(['/login']);
      return false;
    }

    const requiredRole = route.data?.['role'] as string | undefined;
    if (!requiredRole) return true;

    if (this.auth.hasRole(requiredRole)) return true;

    this.router.navigate(['/unauthorized']);
    return false;
  }
}

src/models/user.model.ts
// Keep this lean and aligned with JWT claims the backend issues.
export type Role = 'Admin' | 'Doctor' | 'Patient';

export interface User {
  id: number;
  email: string; // not included in JWT today; may be empty string
  role: Role;
}

src/components/auth/login.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { AuthService } from '../../services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule],
  template: `
    <div class="min-vh-100 d-flex align-items-center justify-content-center bg-light">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-md-6 col-lg-4">
            <div class="card shadow-lg border-0">
              <div class="card-body p-5">
                <div class="text-center mb-4">
                  <h2 class="fw-bold text-primary">Healthcare System</h2>
                  <p class="text-muted">Sign in to your account</p>
                </div>

                <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
                  <div class="mb-3">
                    <label for="email" class="form-label">Email</label>
                    <input
                      type="email"
                      class="form-control"
                      id="email"
                      formControlName="email"
                      [class.is-invalid]="loginForm.get('email')?.invalid && loginForm.get('email')?.touched"
                      autocomplete="username"
                      placeholder="Enter your email">
                    <div class="invalid-feedback">Valid email is required</div>
                  </div>

                  <div class="mb-3">
                    <label for="password" class="form-label">Password</label>
                    <input
                      type="password"
                      class="form-control"
                      id="password"
                      formControlName="password"
                      [class.is-invalid]="loginForm.get('password')?.invalid && loginForm.get('password')?.touched"
                      autocomplete="current-password"
                      placeholder="Enter your password">
                    <div class="invalid-feedback">Password is required</div>
                  </div>

                  <div *ngIf="errorMessage" class="alert alert-danger">{{ errorMessage }}</div>

                  <div class="d-grid">
                    <button type="submit" class="btn btn-primary btn-lg" [disabled]="loginForm.invalid || isLoading">
                      <span *ngIf="isLoading" class="spinner-border spinner-border-sm me-2"></span>
                      Sign In
                    </button>
                  </div>
                </form>

                <div class="text-center mt-4">
                  <p class="text-fant fw-semibold">
                    Don't have an account?
                    <a routerLink="/register" class="text-primary text-decoration-none fw-bold">Register</a>
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `
})
export class LoginComponent {
  loginForm: FormGroup;
  errorMessage = '';
  isLoading = false;

  constructor(private fb: FormBuilder, private auth: AuthService, private router: Router) {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required]
    });
  }

  onSubmit(): void {
    if (this.loginForm.invalid) return;

    this.isLoading = true;
    this.errorMessage = '';

    const { email, password } = this.loginForm.value;

    this.auth.login(email, password).subscribe({
      next: (res) => {
        localStorage.setItem('authToken', res.token);
        this.auth.setCurrentUserFromToken(res.token);

        const user = this.auth.getCurrentUser();
        const rolePath = user?.role ? user.role.toLowerCase() : 'patient';
        this.isLoading = false;
        this.router.navigate([`/${rolePath}`]);
      },
      error: () => {
        this.isLoading = false;
        this.errorMessage = 'Invalid email or password.';
      }
    });
  }
}

src/components/auth/register.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { AuthService } from '../../services/auth.service';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule],
  template: `
    <div class="min-vh-100 d-flex align-items-center justify-content-center bg-light py-5">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-md-8 col-lg-6">
            <div class="card shadow-lg border-0">
              <div class="card-body p-5">
                <div class="text-center mb-4">
                  <h2 class="fw-bold text-primary">Create Account</h2>
                  <p class="text-muted">Join our healthcare system</p>
                </div>

                <form [formGroup]="registerForm" (ngSubmit)="onSubmit()">
                  <div class="mb-3">
                    <label class="form-label">Email</label>
                    <input type="email" class="form-control" formControlName="email"
                      [class.is-invalid]="registerForm.get('email')?.invalid && registerForm.get('email')?.touched" />
                    <div class="invalid-feedback">Valid email is required</div>
                  </div>

                  <div class="mb-3">
                    <label class="form-label">Password</label>
                    <input type="password" class="form-control" formControlName="password"
                      [class.is-invalid]="registerForm.get('password')?.invalid && registerForm.get('password')?.touched" />
                    <div class="invalid-feedback">Password must be at least 6 characters</div>
                  </div>

                  <div class="mb-3">
                    <label class="form-label">Account Type</label>
                    <select class="form-select" formControlName="role"
                      [class.is-invalid]="registerForm.get('role')?.invalid && registerForm.get('role')?.touched">
                      <option value="">Select account type</option>
                      <option value="Patient">Patient</option>
                      <option value="Doctor">Doctor</option>
                      <option value="Admin">Admin</option>
                    </select>
                    <div class="invalid-feedback">Please select an account type</div>
                  </div>

                  <div *ngIf="errorMessage" class="alert alert-danger mt-3">{{ errorMessage }}</div>
                  <div *ngIf="successMessage" class="alert alert-success mt-3">{{ successMessage }}</div>

                  <div class="d-grid mt-4">
                    <button type="submit" class="btn btn-primary btn-lg" [disabled]="registerForm.invalid || isLoading">
                      <span *ngIf="isLoading" class="spinner-border spinner-border-sm me-2"></span>
                      Create Account
                    </button>
                  </div>
                </form>

                <div class="text-center mt-4">
                  <p class="text-fant fw-semibold">
                    Already have an account?
                    <a routerLink="/login" class="text-primary text-decoration-none fw-bold">Sign In</a>
                  </p>
                </div>

                <p class="text-muted mt-3 mb-0" style="font-size: 0.9rem;">
                  Note: Profile details for Doctors/Patients are managed via the respective services by users with proper roles.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `
})
export class RegisterComponent {
  registerForm: FormGroup;
  errorMessage = '';
  successMessage = '';
  isLoading = false;

  constructor(private fb: FormBuilder, private auth: AuthService, private router: Router) {
    this.registerForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      role: ['', Validators.required] // 'Admin' | 'Doctor' | 'Patient'
    });
  }

  onSubmit(): void {
    if (this.registerForm.invalid) return;

    this.isLoading = true;
    this.errorMessage = '';
    this.successMessage = '';

    const { email, password, role } = this.registerForm.value;

    this.auth.register({ email, password, role }).subscribe({
      next: () => {
        this.isLoading = false;
        this.successMessage = 'Registration successful. Redirecting to login...';
        setTimeout(() => this.router.navigate(['/login']), 1200);
      },
      error: (err) => {
        this.isLoading = false;
        this.errorMessage = err?.error?.message || 'Registration failed. Please try again.';
      }
    });
  }
}
